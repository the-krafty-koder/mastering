ğŸ§  Core Concepts
Event loop (phases, call stack, callback queue, microtasks)

Asynchronous programming (callbacks, promises, async/await)

Single-threaded nature of Node.js

Blocking vs non-blocking I/O

Streams (Readable, Writable, Duplex, Transform)

Buffer and binary data handling

ğŸ“ Modules & Architecture
CommonJS vs ES6 Modules

Built-in modules (fs, path, http, events, etc.)

Dependency management (npm/yarn)

Module caching and require mechanics

ğŸ›  Practical APIs
fs (read/write files, sync vs async methods)

http & https (creating servers/clients)

url and querystring modules

events and EventEmitter

Child processes (child_process.fork, spawn, exec)

ğŸ§ª Testing & Debugging
Unit testing with Jest, Mocha, or Tap

Mocking dependencies

Debugging with Node Inspector, console, VSCode debugger

Writing and using testable code

ğŸ”’ Security
Preventing common vulnerabilities (XSS, CSRF, SSRF, SQL injection)

Rate limiting

JWT and session authentication

Secure headers (Helmet)

Environment variables and secrets management

ğŸ§© Package Management
package.json fields (dependencies, scripts, engines)

Semantic versioning

Local vs global packages

Creating a custom package

ğŸ“¦ Frameworks
Express.js (routing, middleware, error handling)

NestJS (if you're going full-stack/typesafe)

Koa, Fastify (alternatives to Express)

ğŸ›  Tooling
Nodemon, PM2

ESLint, Prettier

ts-node (TypeScript in Node.js)

âš™ï¸ Deployment & Operations
Running in production (clustering, process managers)

Dockerizing a Node.js app

Using environment variables (dotenv)

Monitoring/logging (Winston, Morgan)

ğŸ—„ï¸ Databases
Connecting to SQL/NoSQL databases (PostgreSQL, MongoDB, Redis)

ORMs like Sequelize, Prisma, Mongoose

Query optimization and error handling
